"use strict";(self.webpackChunkkognic_sdk_docs=self.webpackChunkkognic_sdk_docs||[]).push([[155],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},s=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),d=l(n),m=o,h=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return n?a.createElement(h,r(r({ref:t},s),{},{components:n})):a.createElement(h,r({ref:t},s))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p[d]="string"==typeof e?e:o,r[1]=p;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7e3:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>p,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const i={id:"annotation_types",title:"Annotation Types"},r=void 0,p={unversionedId:"kognic-io/annotation_types",id:"kognic-io/annotation_types",title:"Annotation Types",description:"Annotation Types are something that can be configured for a project either during or after",source:"@site/docs/kognic-io/annotation_types.md",sourceDirName:"kognic-io",slug:"/kognic-io/annotation_types",permalink:"/docs/kognic-io/annotation_types",draft:!1,editUrl:"https://github.com/annotell/public-docs/docs-src/docs/kognic-io/annotation_types.md",tags:[],version:"current",frontMatter:{id:"annotation_types",title:"Annotation Types"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/kognic-io/overview"},next:{title:"Cameras",permalink:"/docs/kognic-io/scenes/cameras"}},c={},l=[{value:"Examples",id:"examples",level:2},{value:"Get Annotation Types for Project",id:"get-annotation-types-for-project",level:3},{value:"Get Annotation Types for a specified Project Batch",id:"get-annotation-types-for-a-specified-project-batch",level:3},{value:"Create inputs for specific Annotation Types",id:"create-inputs-for-specific-annotation-types",level:3},{value:"Create inputs for all Annotation Types in batch",id:"create-inputs-for-all-annotation-types-in-batch",level:3},{value:"Add/remove annotation types for an input",id:"addremove-annotation-types-for-an-input",level:3}],s={toc:l};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Annotation Types are something that ",(0,o.kt)("strong",{parentName:"p"},"can")," be configured for a project either during or after\nthe Guideline Agreement Process (GAP). During the GAP a set of taxonomies are defined\nwhich will be used in order to annotate all the inputs that are uploaded to the platform."),(0,o.kt)("p",null,"Annotation Types are identifiers that each map to one of these taxonomies and allows you\nto programmatically define, for every input that you create, what taxonomies that you\nwould like that input to be annotated with. You do not ",(0,o.kt)("strong",{parentName:"p"},"need")," to use annotation types\nin a project but by skipping annotation types your inputs would always be created for all\ntaxonomies available in the specified batch."),(0,o.kt)("admonition",{title:"Add additional Annotation Types",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"It is possible to add additional Annotation Types after a project is created, and\nmake them available to future batches that you create. If you would like Annotation\nTypes to be added to your project please get in touch with Kognic's Professional\nServices team.")),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("p",null,"For the following examples we will be creating ",(0,o.kt)("inlineCode",{parentName:"p"},"cameras_sequence")," inputs, however the\nprocedure would be identical for any other input type. We will also assume that the\nproject ",(0,o.kt)("inlineCode",{parentName:"p"},"example_project_id")," is configured with the Annotation Types:\n",(0,o.kt)("inlineCode",{parentName:"p"},"static_objects"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"dynamic_objects"),", and that they are also available in the batch\n",(0,o.kt)("inlineCode",{parentName:"p"},"example_batch_id"),"."),(0,o.kt)("h3",{id:"get-annotation-types-for-project"},"Get Annotation Types for Project"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.client import KognicIOClient\n\nclient = KognicIOClient()\nproject_annotation_types = client.project.get_annotation_types(project="example_project_id")\n')),(0,o.kt)("p",null,"This will return a list of all Annotation Types available in the project."),(0,o.kt)("h3",{id:"get-annotation-types-for-a-specified-project-batch"},"Get Annotation Types for a specified Project Batch"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.client import KognicIOClient\n\nclient = KognicIOClient()\nbatch_annotation_types = client.project.get_annotation_types(project="example_project_id",\n                                                             batch="example_batch_id")\n')),(0,o.kt)("p",null,"This will return a list of all Annotation Types available in the specified batch.\nNote that this list does not need to contain all Annotation Types in the project."),(0,o.kt)("h3",{id:"create-inputs-for-specific-annotation-types"},"Create inputs for specific Annotation Types"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.client import KognicIOClient\nfrom kognic.io.model.scene.cameras_sequence import CamerasSequence\n\nclient = KognicIOClient()\ncamera_input = CamerasSequence(external_id=..., frames=...)\nclient.cameras_sequence.create(camera_input,\n                               project="example_project_id",\n                               batch="example_batch_id",\n                               annotation_types=["static_objects", "dynamic_objects"])\n')),(0,o.kt)("p",null,"The above example will create a new input which will be annotated for the annotation\ntypes specified. If one or more of the specified annotation types would not be available\nin the specified batch the validation in the API would fail. "),(0,o.kt)("admonition",{title:"Specifying batch is optional",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"In these examples we have specified which batch the inputs should be created for, but this is optional. If\nno batch is specified the inputs will be created in the latest batch with status ",(0,o.kt)("inlineCode",{parentName:"p"},"open"),". ")),(0,o.kt)("h3",{id:"create-inputs-for-all-annotation-types-in-batch"},"Create inputs for all Annotation Types in batch"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.client import KognicIOClient\nfrom kognic.io.model.scene.cameras_sequence import CamerasSequence\n\nclient = KognicIOClient()\ncamera_input = CamerasSequence(external_id=..., frames=...)\nclient.cameras_sequence.create(camera_input,\n                               project="example_project_id",\n                               batch="example_batch_id")\n')),(0,o.kt)("p",null,"The above example will create a new input which will be annotated for all Annotation\nTypes available in the batch ",(0,o.kt)("inlineCode",{parentName:"p"},"example_batch_id"),". However, this way it is not explicit\nwhat Annotation Types that the inputs will be annotated with, and you would not get an\nerror if e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"static_objects")," was missing from the specified batch. "),(0,o.kt)("admonition",{title:"Always specify Annotation Types",type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"In order to get the best possible validation it is recommended that you always\nspecify annotation types when you create inputs.")),(0,o.kt)("h3",{id:"addremove-annotation-types-for-an-input"},"Add/remove annotation types for an input"),(0,o.kt)("p",null,"Adding an annotation type to an input means that an annotation will be produced for that input with the specified\nannotation type. In the same way, removing annotation types from an input means that annotations will ",(0,o.kt)("strong",{parentName:"p"},"not")," be\nproduced for that input with the specified annotation types. "),(0,o.kt)("p",null,"In the case when multiple annotation types are annotated in the same task, it is enough to specify\none annotation type when adding but ",(0,o.kt)("strong",{parentName:"p"},"all")," annotation types must be specified when removing. "),(0,o.kt)("p",null,"Note that it is currently not possible to add an annotation type that has already been removed from an input."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.client import KognicIOClient\n\nclient = KognicIOClient()\ninput_uuid = \'cca60a67-cb68-4645-8bae-00c6e6415555\'\n\n# Add an annotation type to an input\nclient.input.add_annotation_type(input_uuid=input_uuid, annotation_type="annotation-type")\n\n# Remove annotation types from an input\nannotation_types = ["annotation-type-1", "annotation-type-2", ...]\nclient.input.remove_annotation_types(input_uuid=input_uuid, annotation_type=annotation_types)\n\n')))}d.isMDXComponent=!0}}]);