"use strict";(self.webpackChunkkognic_sdk_docs=self.webpackChunkkognic_sdk_docs||[]).push([[623],{3905:(e,a,n)=>{n.d(a,{Zo:()=>m,kt:()=>f});var t=n(7294);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function s(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=t.createContext({}),p=function(e){var a=t.useContext(l),n=a;return e&&(n="function"==typeof e?e(a):o(o({},a),e)),n},m=function(e){var a=p(e.components);return t.createElement(l.Provider,{value:a},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,f=c["".concat(l,".").concat(u)]||c[u]||d[u]||r;return n?t.createElement(f,o(o({ref:a},m),{},{components:n})):t.createElement(f,o({ref:a},m))}));function f(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in a)hasOwnProperty.call(a,l)&&(s[l]=a[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4218:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var t=n(7462),i=(n(7294),n(3905));const r={title:"Overview"},o=void 0,s={unversionedId:"kognic-io/overview",id:"kognic-io/overview",title:"Overview",description:"Different types of scenes",source:"@site/docs/kognic-io/overview.md",sourceDirName:"kognic-io",slug:"/kognic-io/overview",permalink:"/docs/kognic-io/overview",draft:!1,editUrl:"https://github.com/annotell/public-docs/docs-src/docs/kognic-io/overview.md",tags:[],version:"current",frontMatter:{title:"Overview"},sidebar:"docs",previous:{title:"Projects",permalink:"/docs/kognic-io/project"},next:{title:"Annotation Types",permalink:"/docs/kognic-io/annotation_types"}},l={},p=[{value:"Different types of scenes",id:"different-types-of-scenes",level:2},{value:"Sequential vs non-sequential",id:"sequential-vs-non-sequential",level:3},{value:"Scene Fields",id:"scene-fields",level:2},{value:"External Id",id:"external-id",level:3},{value:"Sensor Specification",id:"sensor-specification",level:3},{value:"Calibration",id:"calibration",level:3},{value:"Metadata",id:"metadata",level:3},{value:"Frame",id:"frame",level:3},{value:"Non sequential frame",id:"non-sequential-frame",level:4},{value:"Sequential frames",id:"sequential-frames",level:4},{value:"Image &amp; Pointcloud Resources",id:"image--pointcloud-resources",level:2},{value:"Local File",id:"local-file",level:3},{value:"Data in Memory",id:"data-in-memory",level:3},{value:"Data from Callback",id:"data-from-callback",level:3},{value:"Data from Asynchronous Callback (new in version 1.5.0)",id:"data-from-asynchronous-callback-new-in-version-150",level:3},{value:"IMU Data",id:"imu-data",level:2},{value:"Scene Feature Flags",id:"scene-feature-flags",level:2}],m={toc:p};function c(e){let{components:a,...n}=e;return(0,i.kt)("wrapper",(0,t.Z)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"different-types-of-scenes"},"Different types of scenes"),(0,i.kt)("p",null,"A scene represents a grouping of sensor data (e.g. camera images, lidar pointclouds) that should be annotated together. Any information necessary to describe the relationship between the sensors and their captured data is also specifed in the scene, be it camera resolution, sensor name, and the frequency at which the data was recorded at, etc."),(0,i.kt)("p",null,"There are different scene types depending on what kind of sensor(s) are used to represent the contents of the scene. For example, if one wants to create a scene only consisting of image data from camera sensors then one would use the scene type ",(0,i.kt)("inlineCode",{parentName:"p"},"Cameras"),". Similarly, if one wants to create a scene consisting of both lidar and camera sensors then one would use the scene type ",(0,i.kt)("inlineCode",{parentName:"p"},"LidarsAndCameras"),". Additionally, scenes can either be ",(0,i.kt)("em",{parentName:"p"},"single frame")," or ",(0,i.kt)("em",{parentName:"p"},"sequence")," type."),(0,i.kt)("h3",{id:"sequential-vs-non-sequential"},"Sequential vs non-sequential"),(0,i.kt)("p",null,"Sequential scenes represent a ",(0,i.kt)("em",{parentName:"p"},"sequence")," of frames in time, whereas non-sequential scenes only contain one snapshot of the sensor data. The sequential relationship is expressed via a sequence of ",(0,i.kt)("strong",{parentName:"p"},"Frames"),", where each Frame contains information related to what kind of sensor data constitues the frame (e.g. which image and/or pointcloud is part of the Frame) as well as a ",(0,i.kt)("em",{parentName:"p"},"relative timestamp")," that captures where in time (relative to the other frames) the Frame is located."),(0,i.kt)("p",null,"Non-sequential scenes only contains a single Frame and do not require any relative timestamp information."),(0,i.kt)("p",null,"Sequential scene types are identified by the suffix ",(0,i.kt)("inlineCode",{parentName:"p"},"Seq")," in their type name."),(0,i.kt)("p",null,"The following scene types are currently supported"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Cameras")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LidarsAndCameras")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CamerasSeq")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"LidarsAndCamerasSeq")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AggregatedLidarsAndCamerasSeq"))),(0,i.kt)("h2",{id:"scene-fields"},"Scene Fields"),(0,i.kt)("p",null,"Non-sequential scenes have the following structure"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Scene(BaseModel):\n    external_id: str\n    frame: Frame\n    sensor_specification: SensorSpecification\n    calibration_id: Optional[str] # Required if using lidar sensors\n    metadata: Mapping[str, Union[int, float, str, bool]] = field(default_factory=dict)\n")),(0,i.kt)("p",null,"Sequential scenes are similarly represented, except that they instead contain a list of Frames"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class SceneSeq(BaseModel):\n    external_id: str\n    frames: List[Frame]\n    sensor_specification: SensorSpecification\n    calibration_id: Optional[str] # Required if using lidar sensors\n    metadata: Mapping[str, Union[int, float, str, bool]] = field(default_factory=dict)\n")),(0,i.kt)("h3",{id:"external-id"},"External Id"),(0,i.kt)("p",null,"A scene automatically gets a UUID when it is created. This UUID is used as the primary identifier by Kognic and all of our internal systems. Additionally, an external id is required as an identifier when creating the scene in order to make communication around specific scenes easier."),(0,i.kt)("h3",{id:"sensor-specification"},"Sensor Specification"),(0,i.kt)("p",null,"The sensor specification contains information about the camera and/or lidar sensors\nused in the scene."),(0,i.kt)("p",null,'The additional fields are optional, and can be used to specify the order of the camera images and\na human readable sensor name (e.g. "Front Camera" instead of "FC") when viewed in the Kognic annotation App.'),(0,i.kt)("p",null,"As an example, let's say we have three camera sensors ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"L")," positioned on the ego vehicle. Creating a sensor specification would be"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.model.scene.sensor_specification import SensorSpecification\nsensor_spec = SensorSpecification(\n    sensor_to_pretty_name={\n        "R": "Right Camera",\n        "F": "Front Camera",\n        "L": "Left Camera"\n    },\n    sensor_order=["L", "F", "R"]\n)\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sensor_order")," configures the order of camera images, and ",(0,i.kt)("inlineCode",{parentName:"p"},"sensor_to_pretty_name")," affects the labels when viewed in the Kognic annotation App."),(0,i.kt)("h3",{id:"calibration"},"Calibration"),(0,i.kt)("p",null,"Any scene consisting of lidar and camera sensors requires a calibration. The calibration specifies the spatial relationship (position and rotation) between the sensors, and the camera intrinsic parameters."),(0,i.kt)("p",null,"However, scenes without a lidar sensor do not require a calibration."),(0,i.kt)("p",null,"Calibration is used by the Kognic annotation App to project regions in the pointcloud when a camera image is selected, and, similarly, to project the selected object (e.g. point, cuboid) in the pointcloud onto the images ."),(0,i.kt)("p",null,"When creating a calibration, all sensors must match those present on the scene. If this is not the case the scene will not be created and a validation error will be returned by the Kognic API."),(0,i.kt)("p",null,"Detailed documentation on how to create calibrations via the API is present in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/kognic-io/calibrations/overview"},"Calibration section"),"."),(0,i.kt)("h3",{id:"metadata"},"Metadata"),(0,i.kt)("p",null,"Metadata can be added to scenes via the ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata")," field. It consists of flat key-value pairs, which means that nested data structures are not allowed. Metadata can be used to include additional information about a scene.\nMetadata cannot be seen by the annotators, but there are some reserved keywords that can alter the behaviour of the Kognic annotation tool. Reserved keywords can be found in the ",(0,i.kt)("inlineCode",{parentName:"p"},"MetaData")," object in the python client."),(0,i.kt)("h3",{id:"frame"},"Frame"),(0,i.kt)("p",null,"The Frame object specifies the binary data to be annotated (.jpg, .png, .las etc) as well as which sensor the data originated from. Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame")," object is different for each scene type, even though the overall structure is similar (see details below)."),(0,i.kt)("h4",{id:"non-sequential-frame"},"Non sequential frame"),(0,i.kt)("p",null,"As an example, let's say we want to create a scene consiting of images from three camera sensors ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"F")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"L"),". The corresponding binary data are in the files ",(0,i.kt)("inlineCode",{parentName:"p"},"img_cam_R.jpg"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"img_cam_F.jpg")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"img_cam_F.jpg"),". This would correspond the scene type ",(0,i.kt)("inlineCode",{parentName:"p"},"Cameras"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.model.scene.resources import Image\nfrom kognic.io.model.scene.cameras import Cameras, Frame\n\ncameras_scene = Cameras(\n    ...,\n    frame=Frame(\n        images=[\n            Image("img_cam_R.jpg", sensor_name="R"),\n            Image("img_cam_F.jpg", sensor_name="F"),\n            Image("img_cam_L.jpg", sensor_name="L"),\n        ]\n    )\n)\n')),(0,i.kt)("p",null,"Similarly, if we also had an associated lidar pointcloud from the sensor ",(0,i.kt)("inlineCode",{parentName:"p"},"VDL-64")," and a corresponding binary file ",(0,i.kt)("inlineCode",{parentName:"p"},"scan_vdl_64.las"),", we would instead use the scene type ",(0,i.kt)("inlineCode",{parentName:"p"},"LidarsAndCameras"),". Note that the ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame")," class shall be imported under the corresponding scene type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.model.scene.resources import Image, PointCloud\nfrom kognic.io.model.scene.lidars_and_cameras import LidarsAndCameras, Frame\n\nlidars_and_cameras = LidarsAndCameras(\n    ...,\n    frame=Frame(\n        images=[\n            Image("img_cam_R.jpg", sensor_name="R"),\n            Image("img_cam_F.jpg", sensor_name="F"),\n            Image("img_cam_L.jpg", sensor_name="L"),\n        ],\n        point_clouds=[\n            PointCloud("scan_vdl_64.las", sensor_name="VDL-64")\n        ]\n    )\n\n)\n')),(0,i.kt)("h4",{id:"sequential-frames"},"Sequential frames"),(0,i.kt)("p",null,"Sequential scene takes a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame")," objects instead of a single ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame"),". In addition, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame")," object associated with sequential scenes have three additional parameters: ",(0,i.kt)("inlineCode",{parentName:"p"},"frame_id"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"relative_timestamp")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata"),"."),(0,i.kt)("p",null,"The sequential relationship is expressed via the order of the list of ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame"),"."),(0,i.kt)("p",null,"To express how much time has passed between the different frames, one can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"relative_timestamp")," parameter for each ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame"),". The relative timestamp is expressed in milliseconds and describes the relative time between the ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame")," and the start of the scene."),(0,i.kt)("p",null,"For example, let's say that the sensor data is collected and aggregated at 2Hz."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"frame_1 = Frame(..., relative_timestamp=0)\nframe_2 = Frame(..., relative_timestamp=500)\nframe_3 = Frame(..., relative_timestamp=1000)\nframes = [frame_1, frame_2, frame_3]\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"frame_id")," is a string that uniquely identifies each frame in the list of frames."),(0,i.kt)("p",null,"A common use case is to use uuids for each ",(0,i.kt)("inlineCode",{parentName:"p"},"frame_id"),", or a combination of ",(0,i.kt)("inlineCode",{parentName:"p"},"external_id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"frame_index"),".\nFor example, if the ",(0,i.kt)("inlineCode",{parentName:"p"},"external_id")," of the scene is ",(0,i.kt)("inlineCode",{parentName:"p"},"shanghai_20200101")," then the ",(0,i.kt)("inlineCode",{parentName:"p"},"frame_id")," could be encoded as\n",(0,i.kt)("inlineCode",{parentName:"p"},"shanghai_20200101:0")," for the first frame, ",(0,i.kt)("inlineCode",{parentName:"p"},"shanghai_20200101:1")," for the second frame and so on."),(0,i.kt)("p",null,"It's also possible to provide ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata")," on a ",(0,i.kt)("em",{parentName:"p"},"frame")," level for sequential frames. It consists of ",(0,i.kt)("em",{parentName:"p"},"flat")," key-value pairs and is not exposed to annotators during the production of annotators."),(0,i.kt)("p",null,"As an example, let's say we want to create a scene of type ",(0,i.kt)("inlineCode",{parentName:"p"},"CamerasSequence")," consisting of 2 frames, each with camera images\nfrom two sensors ",(0,i.kt)("inlineCode",{parentName:"p"},"R")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"L"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.model.scene.resources import Image\nfrom kognic.io.model.scene.cameras_sequence import CamerasSequence, Frame\n\nframes = [\n    Frame(\n        frame_id="1",\n        relative_timestamp=0,\n        images=[\n            Image("img_L_1.jpg", sensor_name=\'L\'),\n            Image("img_R_1.jpg", sensor_name=\'R\')\n        ]),\n    Frame(\n        frame_id="2",\n        relative_timestamp=500,\n        images=[\n            Image("img_L_2.jpg", sensor_name=\'L\'),\n            Image("img_R_2.jpg", sensor_name=\'R\')\n        ])\n]\n\ncameras_sequence = CamerasSequence(\n        ...,\n        frames=frames,\n    )\n')),(0,i.kt)("h2",{id:"image--pointcloud-resources"},"Image & Pointcloud Resources"),(0,i.kt)("p",null,"Every file containing sensor data is represented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Resource"),", with\n",(0,i.kt)("inlineCode",{parentName:"p"},"Image")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PointCloud")," being the concrete subclasses."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Resource(ABC, BaseSerializer):\n    filename: str\n    resource_id: Optional[str] = None\n    sensor_name: str\n    file_data: Optional[FileData] = Field(default=None, exclude=True)\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Resource"),"s ultimately describe how to obtain some binary or textual sensor data, which can be done in different ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Indirectly: by refering to a local filename that contains the data"),(0,i.kt)("li",{parentName:"ol"},"Directly: provide some bytes-like object at creation time"),(0,i.kt)("li",{parentName:"ol"},"Lazily: provide a callback function which can provide the bytes later in the process")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Resource"),"s must always be given a ",(0,i.kt)("inlineCode",{parentName:"p"},"filename"),". For alternative 1 this must point to the local file to upload. For alternatives 2 & 3 the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"filename")," parameter is treated as an identifier; it is used to name the uploaded file but does not have to correspond to anything in the filesystem."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Resource"),"s also always have a ",(0,i.kt)("inlineCode",{parentName:"p"},"sensor_name")," which identifies the sensor they were captured from. In sequential scenes, each ",(0,i.kt)("inlineCode",{parentName:"p"},"Frame")," will have a ",(0,i.kt)("inlineCode",{parentName:"p"},"Resource")," for each sensor."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Resource"),"s take their actual data (bytes) from ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),", a ",(0,i.kt)("inlineCode",{parentName:"p"},"BinaryIO")," or an ",(0,i.kt)("inlineCode",{parentName:"p"},"IOBase"),"-compatible object. These are referred to with the type alias ",(0,i.kt)("inlineCode",{parentName:"p"},"UploadableData  = Union[bytes, BinaryIO, IOBase]"),"."),(0,i.kt)("p",null,"For alternatives 2 & 3 listed above, a ",(0,i.kt)("inlineCode",{parentName:"p"},"FileData")," object is attached to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Image")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"PointCloud")," to capture the source of data. It is created with either ",(0,i.kt)("inlineCode",{parentName:"p"},"data: UploadableData")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"callback: Callable[[str], UploadableData]"),", as well as a ",(0,i.kt)("inlineCode",{parentName:"p"},"format")," which identifies the type of data contained in the bytes."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Previous API client releases advertised support for ingesting files from external URIs, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"gs://bucket/path/file"),". Please contact Kognic if you believe you require this functionality going forward.")),(0,i.kt)("h3",{id:"local-file"},"Local File"),(0,i.kt)("p",null,"Set ",(0,i.kt)("inlineCode",{parentName:"p"},"filename")," to the path of the local file and do not provide data via other means (directly or callback). The content is uploaded using a content type inferred from the filename suffix."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'Image(filename="/Users/johndoe/images/img_FC.png",\n      sensor_name="FC")\n')),(0,i.kt)("h3",{id:"data-in-memory"},"Data in Memory"),(0,i.kt)("p",null,"In addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"filename"),", provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"FileData")," object via the ",(0,i.kt)("inlineCode",{parentName:"p"},"file_data")," attribute, which in turn has an ",(0,i.kt)("inlineCode",{parentName:"p"},"UploadableData")," as its own ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," attribute. This example uses raw ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'png_blob = FileData(data=b\'some PNG bytes\',\n                    format=FileData.Format.PNG)\nImage(filename="FC-frame15",\n      sensor_name="FC",\n      file_data=png_blob)\n')),(0,i.kt)("h3",{id:"data-from-callback"},"Data from Callback"),(0,i.kt)("p",null,"In addition to ",(0,i.kt)("inlineCode",{parentName:"p"},"filename"),", provide a ",(0,i.kt)("inlineCode",{parentName:"p"},"FileData")," object via the ",(0,i.kt)("inlineCode",{parentName:"p"},"file_data")," attribute, with a ",(0,i.kt)("inlineCode",{parentName:"p"},"callback")," function that produces an ",(0,i.kt)("inlineCode",{parentName:"p"},"UploadableData"),", e.g."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'png_from_callback = FileData(callback=get_png, format=FileData.Format.PNG)\nImage(\n    filename="FC-frame15",\n    sensor_name="FC",\n    file_data=png_from_callback\n)\n')),(0,i.kt)("p",null,"The callback function (",(0,i.kt)("inlineCode",{parentName:"p"},"get_png"),") is a unary function with the following signature."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def get_png(file: str) -> UploadableData:\n    pass\n")),(0,i.kt)("p",null,"The callback function is invoked with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Resource.filename")," as its argument when it is time to upload that single file."),(0,i.kt)("p",null,"If the callback requires extra arguments then we recommend creating a closure over the additional arguments like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'def get_callback(arg1, arg2, **kwargs):\n     def callback(filename) -> bytes:\n         # ... use arg1, arg2, filename and kwargs\n\n     return callback\n\nFileData(\n    callback=get_callback("foo", "bar", extra1="baz", extra2="qux"),\n    format=FileData.Format.JPG\n)\n')),(0,i.kt)("h3",{id:"data-from-asynchronous-callback-new-in-version-150"},"Data from Asynchronous Callback (new in version 1.5.0)"),(0,i.kt)("p",null,"Using asynchronous callbacks can be useful to speed up data uploads, especially when the data is not available locally.\nIn the same way as for synchronous callbacks, the callback function is invoked with the ",(0,i.kt)("inlineCode",{parentName:"p"},"Resource.filename")," as its\nargument when it is time to upload that single file. Asynchronous callbacks can be used in the following way:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'async def get_png(filename: str) -> UploadableData:\n    pass\n\npng_from_async_callback = FileData(callback=get_png, format=FileData.Format.PNG)\n\nImage(\n    filename="FC-frame15",\n    sensor_name="FC",\n    file_data=png_from_async_callback\n)\n')),(0,i.kt)("h2",{id:"imu-data"},"IMU Data"),(0,i.kt)("p",null,"Inertial Measurement Unit (IMU) data may be provided for scenes containing LIDAR pointclouds. This can be used to\nperform motion compensation in multi-lidar setups, and by default if any IMU data is provided this will be done.\nMotion compensation may be disabled via a ",(0,i.kt)("a",{parentName:"p",href:"feature_flags"},"scene feature flag"),", for cases where motion compensation has\nalready been performed prior to upload."),(0,i.kt)("p",null,"Refer to ",(0,i.kt)("a",{parentName:"p",href:"scenes/lidars_with_imu_data"},"Motion Compensation for Multi-Lidar Setups"),"."),(0,i.kt)("h2",{id:"scene-feature-flags"},"Scene Feature Flags"),(0,i.kt)("p",null,"Control over optional parts of the scene creation process is possible via ",(0,i.kt)("inlineCode",{parentName:"p"},"FeatureFlags")," that are passed when invoking\nthe create operation on the scene. Refer to ",(0,i.kt)("a",{parentName:"p",href:"feature_flags"},"the feature flags documentation")," for details."))}c.isMDXComponent=!0}}]);