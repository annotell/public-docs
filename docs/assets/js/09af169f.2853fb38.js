"use strict";(self.webpackChunkkognic_sdk_docs=self.webpackChunkkognic_sdk_docs||[]).push([[261],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},s=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),m=d(t),u=r,f=m["".concat(l,".").concat(u)]||m[u]||c[u]||o;return t?a.createElement(f,i(i({ref:n},s),{},{components:t})):a.createElement(f,i({ref:n},s))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=u;var p={};for(var l in n)hasOwnProperty.call(n,l)&&(p[l]=n[l]);p.originalType=e,p[m]="string"==typeof e?e:r,i[1]=p;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},1497:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>d});var a=t(7462),r=(t(7294),t(3905));const o={title:"The prediction format"},i=void 0,p={unversionedId:"dataset-refinement/prediction-format",id:"dataset-refinement/prediction-format",title:"The prediction format",description:"Predictions use the OpenLabel format/schema. This is the same format as the one used",source:"@site/docs/dataset-refinement/prediction-format.md",sourceDirName:"dataset-refinement",slug:"/dataset-refinement/prediction-format",permalink:"/docs/dataset-refinement/prediction-format",draft:!1,editUrl:"https://github.com/annotell/public-docs/docs-src/docs/dataset-refinement/prediction-format.md",tags:[],version:"current",frontMatter:{title:"The prediction format"},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/dataset-refinement/introduction"},next:{title:"Uploading predictions",permalink:"/docs/dataset-refinement/uploading-predictions"}},l={},d=[{value:"Supported prediction features",id:"supported-prediction-features",level:2},{value:"Prediction examples",id:"prediction-examples",level:2},{value:"2D bounding box with a static property",id:"2d-bounding-box-with-a-static-property",level:3},{value:"3D cuboid with a static property",id:"3d-cuboid-with-a-static-property",level:3},{value:"Using <code>kognic-openlabel</code> to validate the format",id:"using-kognic-openlabel-to-validate-the-format",level:3}],s={toc:d};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Predictions use the OpenLabel format/schema. This is the same format as the one used\nfor ",(0,r.kt)("a",{parentName:"p",href:"../kognic-io/pre_annotations/#openlabel-support"},"uploading pre-annotations"),". General information about the\nOpenLabel format can be found in ",(0,r.kt)("a",{parentName:"p",href:"../openlabel/openlabel-format"},"here"),"."),(0,r.kt)("h2",{id:"supported-prediction-features"},"Supported prediction features"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Only one type of geometry, e.g. cuboid, per prediction is supported")),(0,r.kt)("p",null,"The current API for uploading predictions supports the following geometries:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Name"),(0,r.kt)("th",{parentName:"tr",align:null},"OpenLABEL field"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Cuboid"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"cuboid")),(0,r.kt)("td",{parentName:"tr",align:null},"Cuboid in 3D")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Bounding box"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bbox")),(0,r.kt)("td",{parentName:"tr",align:null},"Bounding box in 2D")))),(0,r.kt)("p",null,"Note that all geometries should be specified under frames rather than in the root of the pre-annotation. The rotation of\ncuboids should be the same as that in ",(0,r.kt)("a",{parentName:"p",href:"/docs/openlabel/openlabel-format#rotation-of-cuboids"},"exports"),". 2D geometries\nshould be expressed in pixel coordinates. See ",(0,r.kt)("a",{parentName:"p",href:"/docs/kognic-io/coordinate_systems"},"coordinate systems")," for more\ninformation."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"frame_properties")," is required, same as for uploading pre annotations. For non-video\ndata, ",(0,r.kt)("inlineCode",{parentName:"p"},"frame_properties.external_id")," will be resolved automatically if it is left as an empty string.\n",(0,r.kt)("inlineCode",{parentName:"p"},"frame_properties.timestamp")," will be ignored for non-video data and can therefore be set to 0. ",(0,r.kt)("inlineCode",{parentName:"p"},"frame_properties.stream"),"\ncan be left as an empty dict."),(0,r.kt)("p",null,"Existence confidence can be provided by specifying an attribute called ",(0,r.kt)("inlineCode",{parentName:"p"},"confidence"),". It is not required and will be set\nto 1.0 if it is left empty. If provided, it must be defined as a numeric value between 0.0 and 1.0. Existence confidence\nis set to 0.85 in the examples below."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"camera_id")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"lidar_id")," in the examples below must match the id of the sensor in already existing annotations."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"object_data.type")," will show up as the class name in the tool."),(0,r.kt)("h2",{id:"prediction-examples"},"Prediction examples"),(0,r.kt)("h3",{id:"2d-bounding-box-with-a-static-property"},"2D bounding box with a static property"),(0,r.kt)("p",null,"In OpenLabel, a bounding box is represented as a list of 4 values: ",(0,r.kt)("inlineCode",{parentName:"p"},"[x, y, width, height]"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," are the\ncenter coordinates of the bounding box. The ",(0,r.kt)("inlineCode",{parentName:"p"},"width")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"height")," are the width and height of the bounding box. The ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," coordinates are relative to the upper left corner of the image."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "openlabel": {\n    "frames": {\n      "0": {\n        "frame_properties": {\n          "timestamp": 0,\n          "external_id": "",\n          "streams": {}\n        },\n        "objects": {\n          "1232b4f4-e3ca-446a-91cb-d8d403703df7": {\n            "object_data": {\n              "bbox": [\n                {\n                  "attributes": {\n                    "num": [\n                      {\n                        "val": 0.85,\n                        "name": "confidence"\n                      }\n                    ],\n                    "text": [\n                      {\n                        "name": "stream",\n                        "val": "camera_id"\n                      }\n                    ]\n                  },\n                  "name": "any-human-readable-bounding-box-name",\n                  "val": [\n                    1.0,\n                    1.0,\n                    40.0,\n                    30.0\n                  ]\n                }\n              ]\n            }\n          }\n        }\n      }\n    },\n    "metadata": {\n      "schema_version": "1.0.0"\n    },\n    "objects": {\n      "1232b4f4-e3ca-446a-91cb-d8d403703df7": {\n        "name": "any-human-readable-bounding-box-name",\n        "object_data": {\n          "text": [\n            {\n              "name": "color",\n              "val": "red"\n            }\n          ]\n        },\n        "type": "PassengerCar"\n      }\n    },\n    "streams": {\n      "camera_id": {\n        "type": "camera"\n      }\n    }\n  }\n}\n')),(0,r.kt)("h3",{id:"3d-cuboid-with-a-static-property"},"3D cuboid with a static property"),(0,r.kt)("p",null,"Cuboids are represented as a list of 10 values: ",(0,r.kt)("inlineCode",{parentName:"p"},"[x, y, z, qx, qy, qz, qw, width, length, height]"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),",\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"z")," are the center coordinates of the cuboid. ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"y"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"z"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"width"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"length"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"height")," are in meters.\n",(0,r.kt)("inlineCode",{parentName:"p"},"qx"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"qy"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"qz"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"qw")," are the quaternion values for the rotation of the cuboid."),(0,r.kt)("p",null,"Read more about coordinate systems and\nquaternions ",(0,r.kt)("a",{parentName:"p",href:"../openlabel/openlabel-format/#rotation-of-cuboids"},"here"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "openlabel": {\n    "frames": {\n      "0": {\n        "frame_properties": {\n          "timestamp": 0,\n          "external_id": "",\n          "streams": {}\n        },\n        "objects": {\n          "1232b4f4-e3ca-446a-91cb-d8d403703df7": {\n            "object_data": {\n              "cuboid": [\n                {\n                  "attributes": {\n                    "num": [\n                      {\n                        "val": 0.85,\n                        "name": "confidence"\n                      }\n                    ],\n                    "text": [\n                      {\n                        "name": "stream",\n                        "val": "lidar_id"\n                      }\n                    ]\n                  },\n                  "name": "any-human-readable-cuboid-name",\n                  "val": [\n                    2.079312801361084,\n                    -18.919870376586914,\n                    0.3359137773513794,\n                    -0.002808041640852679,\n                    0.022641949116037438,\n                    0.06772797660868829,\n                    0.9974429197838155,\n                    1.767102435869269,\n                    4.099334155319101,\n                    1.3691029802958168\n                  ]\n                }\n              ]\n            }\n          }\n        }\n      }\n    },\n    "metadata": {\n      "schema_version": "1.0.0"\n    },\n    "objects": {\n      "1232b4f4-e3ca-446a-91cb-d8d403703df7": {\n        "name": "any-human-readable-cuboid-name",\n        "object_data": {\n          "text": [\n            {\n              "name": "color",\n              "val": "red"\n            }\n          ]\n        },\n        "type": "PassengerCar"\n      }\n    },\n    "streams": {\n      "lidar_id": {\n        "type": "lidar"\n      }\n    }\n  }\n}\n')),(0,r.kt)("h3",{id:"using-kognic-openlabel-to-validate-the-format"},"Using ",(0,r.kt)("inlineCode",{parentName:"h3"},"kognic-openlabel")," to validate the format"),(0,r.kt)("p",null,"See ",(0,r.kt)("a",{parentName:"p",href:"https://pypi.org/project/kognic-openlabel/"},"kognic-openlabel")," for more information."))}m.isMDXComponent=!0}}]);