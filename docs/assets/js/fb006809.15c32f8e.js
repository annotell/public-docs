"use strict";(self.webpackChunkkognic_sdk_docs=self.webpackChunkkognic_sdk_docs||[]).push([[164],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>k});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=r(e,["components","mdxType","originalType","parentName"]),c=p(a),u=i,k=c["".concat(s,".").concat(u)]||c[u]||d[u]||o;return a?n.createElement(k,l(l({ref:t},m),{},{components:a})):n.createElement(k,l({ref:t},m))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,l=new Array(o);l[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[c]="string"==typeof e?e:i,l[1]=r;for(var p=2;p<o;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7211:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const o={title:"Custom Camera Calibrations"},l=void 0,r={unversionedId:"kognic-io/calibrations/cameras-custom",id:"kognic-io/calibrations/cameras-custom",title:"Custom Camera Calibrations",description:"This feature is new in version 1.8.0 of kognic-io and some parts require optional dependencies. Run pip install kognic-io[wasm] to install it.",source:"@site/docs/kognic-io/calibrations/cameras-custom.md",sourceDirName:"kognic-io/calibrations",slug:"/kognic-io/calibrations/cameras-custom",permalink:"/docs/kognic-io/calibrations/cameras-custom",draft:!1,editUrl:"https://github.com/annotell/public-docs/docs-src/docs/kognic-io/calibrations/cameras-custom.md",tags:[],version:"current",frontMatter:{title:"Custom Camera Calibrations"},sidebar:"docs",previous:{title:"Standard Camera Calibrations",permalink:"/docs/kognic-io/calibrations/cameras-standard"},next:{title:"Coordinate Systems",permalink:"/docs/kognic-io/coordinate_systems"}},s={},p=[{value:"The WebAssembly module",id:"the-webassembly-module",level:2},{value:"Validation",id:"validation",level:2},{value:"Compilation",id:"compilation",level:2},{value:"Example: Rust",id:"example-rust",level:3},{value:"Rust with Cargo",id:"rust-with-cargo",level:4},{value:"Example: C++",id:"example-c",level:3},{value:"Example: C",id:"example-c-1",level:3}],m={toc:p};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This feature is new in version 1.8.0 of kognic-io and some parts require optional dependencies. Run ",(0,i.kt)("inlineCode",{parentName:"p"},"pip install kognic-io[wasm]")," to install it.")),(0,i.kt)("p",null,"If your calibration is not in the list of supported standard camera calibrations, you can provide a custom calibration. The table below\nshow the attributes of the ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomCameraCalibration")," object. The ",(0,i.kt)("inlineCode",{parentName:"p"},"wasm_base64")," attribute is a base64 encoded string of the\nWebAssembly module that implements the calibration. The ",(0,i.kt)("inlineCode",{parentName:"p"},"test_cases")," attribute is a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"TestCase")," objects that are used\nto validate the calibration during creation. It is recommended to provide a few test cases to make sure that the\ncalibration is correct. "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"rotation_quaternion")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"RotationQuaternion")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"w"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"z"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"position")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"Position")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"z"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"image_width")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Integer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"image_height")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Integer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"wasm_base64")),(0,i.kt)("td",{parentName:"tr",align:"left"},"String"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"test_cases")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A list of ",(0,i.kt)("inlineCode",{parentName:"td"},"TestCase")," objects"),(0,i.kt)("td",{parentName:"tr",align:"left"},"point3d, point2d")))),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomCameraCalibration")," object can conveniently be instantiated directly from the binary or\na wasm-file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'calibration_file = CustomCameraCalibration.from_file("/path/to/calibration.wasm", ...)\ncalibration_binary = CustomCameraCalibration.from_bytes(b"...", ...)\n')),(0,i.kt)("p",null,"We provide a set of utilities that will make it easier to work with the WebAssembly module. More specifically we provide\nvalidation code and compilation code from a few different languages to WebAssembly. The code is available both as python\nfunctions and via the ",(0,i.kt)("inlineCode",{parentName:"p"},"kognicutil")," cli."),(0,i.kt)("h2",{id:"the-webassembly-module"},"The WebAssembly module"),(0,i.kt)("p",null,"The WebAssembly must follow a strict interface where the module exports a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"project_point_to_image"),". The\nfunction must take three arguments of type ",(0,i.kt)("inlineCode",{parentName:"p"},"float64")," and return two values of type ",(0,i.kt)("inlineCode",{parentName:"p"},"float64"),". Thus, the WebAssembly text representation of\nthis interface is ",(0,i.kt)("inlineCode",{parentName:"p"},"func (param f64 f64 f64) (result f64 f64)"),". The three arguments are the x, y and z coordinates of\nthe 3D point. The two return values are the x and y coordinates of the projected point in the image plane. WebAssembly\ndoesn't support multiple return values by default but this can be enabled with the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/WebAssembly/multi-value"},"multi-value"),"\nproposal."),(0,i.kt)("p",null,"If the point is not within the field of view, the function should return ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/NaN"},"NaN")," for\nboth the x and y coordinates."),(0,i.kt)("h2",{id:"validation"},"Validation"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This requires ",(0,i.kt)("inlineCode",{parentName:"p"},"wasmtime")," to be installed which is an optional of dependency kognic-io. Run ",(0,i.kt)("inlineCode",{parentName:"p"},"pip install kognic-io[wasm]")," to\ninstall it.")),(0,i.kt)("p",null,"We provide validation code both as python functions and via the ",(0,i.kt)("inlineCode",{parentName:"p"},"kognicutil")," cli. We validate things such as but not limited to"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The module can be loaded"),(0,i.kt)("li",{parentName:"ol"},"The function exists and has the correct signature"),(0,i.kt)("li",{parentName:"ol"},"That a point can be projected using the module"),(0,i.kt)("li",{parentName:"ol"},"That points are projected correctly if test cases are provided")),(0,i.kt)("p",null,"In python there are three different ways to validate a calibration"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'import kognic.io.tools.calibration.validation as wasm_validation\nfrom kognic.io.model.calibration.camera.custom_camera_calibration import CustomCameraCalibration, Point2d, Point3d, TestCase\n\ntest_cases = [\n    TestCase(\n        point3d=Point3d(x=1.0, y=2.0, z=3.0),\n        point2d=Point2d(x=2.0, y=5.6)\n    ),\n    TestCase(\n        point3d=Point3d(x=1.0, y=1.0, z=-1.0),\n        point2d=Point2d(x=float("nan"), y=float("nan")) # point is outside field of view\n    )\n]\n\nwasm_file = "/path/to/calibration.wasm"\ncalibration = CustomCameraCalibration.from_bytes(wasm_file, test_cases=test_cases, ...)\nwasm_bytes = calibration.to_bytes()\n\n# Validate the calibration object\nwasm_validation.validate_custom_camera_calibration(calibration, test_cases=test_cases)\n\n# Validate the wasm file\nwasm_validation.validate_wasm_file(wasm_file, test_cases=test_cases)\n\n# Validate the wasm binary\nwasm_validation.validate_wasm_bytes(wasm_bytes, test_cases=test_cases)\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"kognicutil")," cli can be used as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm validate calibration.wasm\n")),(0,i.kt)("h2",{id:"compilation"},"Compilation"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"It is recommended to keep the wasm file as small as possible. Try to avoid dependencies that are not needed. For example,\nit may be preferred to implement some mathematical functions yourself instead of using the standard library.")),(0,i.kt)("p",null,"As stated above the WebAssembly module must follow a strict interface and compilation requires the multi-value proposal.\nWe provide a set of utilities that will make it easier to compile the WebAssembly module from a few languages, see table below. "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Language")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Target")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Compilation tool")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Rust"),(0,i.kt)("td",{parentName:"tr",align:null},"*.rs"),(0,i.kt)("td",{parentName:"tr",align:null},"rustc")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Rust (Cargo)"),(0,i.kt)("td",{parentName:"tr",align:null},"Cargo.toml"),(0,i.kt)("td",{parentName:"tr",align:null},"cargo")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"C++"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("em",{parentName:"td"},".cc, "),".cpp"),(0,i.kt)("td",{parentName:"tr",align:null},"emscripten")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"C"),(0,i.kt)("td",{parentName:"tr",align:null},"*.c"),(0,i.kt)("td",{parentName:"tr",align:null},"emscripten")))),(0,i.kt)("p",null,"The utilities are available both as python functions and via the ",(0,i.kt)("inlineCode",{parentName:"p"},"kognicutil")," cli. From Python, you can compile the module\nwith "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.tools.calibration.compilation import compile_to_wasm\nwasm_binary = compile_to_wasm("path/to/source")\n')),(0,i.kt)("p",null,"The returned binary can then be used to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomCameraCalibration")," object. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"output_wasm")," parameter is passed,\nthe binary will be saved to the specified path. The ",(0,i.kt)("inlineCode",{parentName:"p"},"kognicutil")," cli can be used as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm compile path/to/source path/to/output.wasm\n")),(0,i.kt)("p",null,"Note that, validation is run by default after compilation. This can be disabled with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--skip-validation")," flag."),(0,i.kt)("p",null,"Calibration parameters have to be embedded in the binary so that they can be used by the WebAssembly module. Try to\npre-compute as much as possible to increase the speed of the projection function at runtime."),(0,i.kt)("p",null,"Below follows examples of a simplified version of the pinhole calibration in a few different languages."),(0,i.kt)("h3",{id:"example-rust"},"Example: Rust"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/annotell/kognic-io-examples-python/tree/master/examples/calibration/custom/pinhole.rs"},"Rust file"),"\ncan be compiled with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm compile path/to/source.rs path/to/output.wasm\n")),(0,i.kt)("p",null,"Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"panics")," are not supported and compilation will fail if the code contains it."),(0,i.kt)("h4",{id:"rust-with-cargo"},"Rust with Cargo"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/annotell/kognic-io-examples-python/tree/master/examples/calibration/custom/pinhole-rust-cargo"},"Rust module with Cargo"),"\ncan be compiled with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm compile path/to/source/Cargo.toml path/to/output.wasm\n")),(0,i.kt)("p",null,"Note that it is important to specify that the library is a ",(0,i.kt)("inlineCode",{parentName:"p"},"cdylib")," and it is also recommended to set ",(0,i.kt)("inlineCode",{parentName:"p"},"strip = true")," to\nreduce the size of the WebAssembly module. This is done by adding the following to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Cargo.toml")," file"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-toml"},'[lib]\ncrate-type = ["cdylib"]\n\n[profile.release]\nstrip = true\n')),(0,i.kt)("h3",{id:"example-c"},"Example: C++"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/annotell/kognic-io-examples-python/tree/master/examples/calibration/custom/pinhole.cc"},"C++ file"),"\ncan be compiled with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm compile path/to/source.cc path/to/output.wasm\n")),(0,i.kt)("p",null,"or with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm compile path/to/source.cpp path/to/output.wasm\n")),(0,i.kt)("h3",{id:"example-c-1"},"Example: C"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/annotell/kognic-io-examples-python/tree/master/examples/calibration/custom/pinhole.c"},"C++ file"),"\ncan be compiled with"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"kognicutil wasm compile path/to/source.c path/to/output.wasm\n")))}c.isMDXComponent=!0}}]);