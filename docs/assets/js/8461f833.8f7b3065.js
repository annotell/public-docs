"use strict";(self.webpackChunkkognic_sdk_docs=self.webpackChunkkognic_sdk_docs||[]).push([[456],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>h});var a=n(7294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},r=Object.keys(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var p=a.createContext({}),s=function(t){var e=a.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},u=function(t){var e=s(t.components);return a.createElement(p.Provider,{value:e},t.children)},d="mdxType",c={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,r=t.originalType,p=t.parentName,u=l(t,["components","mdxType","originalType","parentName"]),d=s(n),m=i,h=d["".concat(p,".").concat(m)]||d[m]||c[m]||r;return n?a.createElement(h,o(o({ref:e},u),{},{components:n})):a.createElement(h,o({ref:e},u))}));function h(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var r=n.length,o=new Array(r);o[0]=m;var l={};for(var p in e)hasOwnProperty.call(e,p)&&(l[p]=e[p]);l.originalType=t,l[d]="string"==typeof t?t:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9186:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={title:"Working with Inputs"},o=void 0,l={unversionedId:"kognic-io/working_with_inputs",id:"kognic-io/working_with_inputs",title:"Working with Inputs",description:"Creating Inputs",source:"@site/docs/kognic-io/working_with_inputs.md",sourceDirName:"kognic-io",slug:"/kognic-io/working_with_inputs",permalink:"/docs/kognic-io/working_with_inputs",draft:!1,editUrl:"https://github.com/annotell/public-docs/docs-src/docs/kognic-io/working_with_inputs.md",tags:[],version:"current",frontMatter:{title:"Working with Inputs"},sidebar:"docs",previous:{title:"Aggregated Lidars and Cameras Sequence",permalink:"/docs/kognic-io/inputs/aggregated_lidars_and_cameras_seq"},next:{title:"Pre-annotations",permalink:"/docs/kognic-io/pre_annotations"}},p={},s=[{value:"Creating Inputs",id:"creating-inputs",level:2},{value:"Adding inputs to the latest open batch for a project",id:"adding-inputs-to-the-latest-open-batch-for-a-project",level:3},{value:"Adding inputs to specified batch in a project",id:"adding-inputs-to-specified-batch-in-a-project",level:3},{value:"Input Status",id:"input-status",level:2},{value:"List Inputs",id:"list-inputs",level:2},{value:"Response",id:"response",level:3},{value:"Invalidate Inputs",id:"invalidate-inputs",level:2},{value:"List Invalidated Inputs",id:"list-invalidated-inputs",level:2},{value:"Creating Multiple Inputs With One Call",id:"creating-multiple-inputs-with-one-call",level:2}],u={toc:s};function d(t){let{components:e,...n}=t;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"creating-inputs"},"Creating Inputs"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"For detailed information about different input modalities, check the Input Types section.")),(0,i.kt)("admonition",{title:"Kognic Users",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"As a Kognic user, it is possible to specify ",(0,i.kt)("inlineCode",{parentName:"p"},"client_organization_id")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"KognicIOClient")," constructor to create inputs on behalf of a client organization")),(0,i.kt)("p",null,"In order to create inputs, they need to be associated with a ",(0,i.kt)("a",{parentName:"p",href:"project"},"project")," and an ",(0,i.kt)("a",{parentName:"p",href:"project#batch"},"input batch"),". Consider the following project setup:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"organization # root for projects\n\u2514\u2500\u2500 projects\n   \u251c\u2500\u2500 project-a\n       \u251c\u2500\u2500 batch-1 - completed\n       \u251c\u2500\u2500 batch-2 - open\n           \u251c\u2500\u2500 input 0edb8f59-a8ea-4c9b-aebb-a3caaa6f2ba3\n           \u251c\u2500\u2500 input 37d9dda4-3a29-4fcb-8a71-6bf16d5a9c36\n           \u2514\u2500\u2500 ...\n       \u2514\u2500\u2500 batch-3 - pending\n   \u2514\u2500\u2500 project-b\n       \u251c\u2500\u2500 batch-1\n       \u2514\u2500\u2500 ...\n")),(0,i.kt)("p",null,"There are 2 ways to associate inputs with a project and batch:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Adding inputs to the latest open batch for a project"),(0,i.kt)("li",{parentName:"ul"},"Adding inputs to specified batch for a project")),(0,i.kt)("p",null,"The following examples all use an input of type ",(0,i.kt)("inlineCode",{parentName:"p"},"Cameras"),", however the interface applies to all input types. Note that\nwe also provide a wrapper function ",(0,i.kt)("inlineCode",{parentName:"p"},"create_inputs")," to help with this process, see ",(0,i.kt)("a",{parentName:"p",href:"#creating-multiple-inputs-with-one-call"},"Creating Multiple Inputs With One Call"),"."),(0,i.kt)("h3",{id:"adding-inputs-to-the-latest-open-batch-for-a-project"},"Adding inputs to the latest open batch for a project"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'client.cameras.create(\n    ...,\n    project="project-a")\n')),(0,i.kt)("p",null,"Will add inputs to ",(0,i.kt)("inlineCode",{parentName:"p"},"project-a")," ",(0,i.kt)("inlineCode",{parentName:"p"},"batch-2")," because it's the latest open batch."),(0,i.kt)("h3",{id:"adding-inputs-to-specified-batch-in-a-project"},"Adding inputs to specified batch in a project"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'client.cameras.create(\n    ...,\n    project="project-a",\n    batch="batch-3")\n')),(0,i.kt)("p",null,"Will add inputs to ",(0,i.kt)("inlineCode",{parentName:"p"},"project-a")," ",(0,i.kt)("inlineCode",{parentName:"p"},"batch-3"),"."),(0,i.kt)("h2",{id:"input-status"},"Input Status"),(0,i.kt)("p",null,"Once an input has been created, it might be preprocessed before being made available for annotation. Also, postprocessing such as conversion to the client-specific format might take place after annotation has been performed. During this process, the status property of an input can be used to keep track of progress."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Status"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"pending"),(0,i.kt)("td",{parentName:"tr",align:null},"Input has been validated but the server is waiting for the associated data to be uploaded")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"processing"),(0,i.kt)("td",{parentName:"tr",align:null},"Associated data has been uploaded and is currently being processed by the Kognic Platform, potentially performing conversion of file formats")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"created"),(0,i.kt)("td",{parentName:"tr",align:null},"Input is created and available for annotation")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"failed"),(0,i.kt)("td",{parentName:"tr",align:null},"Conversion of input failed")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"invalidated:broken-input"),(0,i.kt)("td",{parentName:"tr",align:null},"Input was invalidated since it did not load")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"invalidated:duplicate"),(0,i.kt)("td",{parentName:"tr",align:null},"Input was invalidated due to being uploaded several times")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"invalidated:incorrectly-created"),(0,i.kt)("td",{parentName:"tr",align:null},"Input was invalidated because it was incorrectly created")))),(0,i.kt)("h2",{id:"list-inputs"},"List Inputs"),(0,i.kt)("p",null,"Inputs can be retrieved from the API in two ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Filtering on a project using the ",(0,i.kt)("inlineCode",{parentName:"li"},"get_inputs")," method. Additional filter parameters are also available\n(see table below) for querying inputs."),(0,i.kt)("li",{parentName:"ol"},"Providing the input uuids of the inputs to be retrieved using the ",(0,i.kt)("inlineCode",{parentName:"li"},"get_inputs_by_uuids")," method")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# List all inputs for a project\nclient.input.get_inputs(project="project-identifier")\n\n# List all inputs for a project and a batch\nclient.input.get_inputs(project="project-identifier", batch="batch-identifier") \n\n# List all inputs for specific input uuids\ninput_uuids = [\'cca60a67-cb68-4645-8bae-00c6e6415555\', \'cc8776d0-f537-4094-8b11-8c2111741e2f\', ...]\nclient.input.get_inputs_by_uuids(input_uuids=input_uuids)\n')),(0,i.kt)("p",null,"Additional filter parameters for querying inputs using ",(0,i.kt)("inlineCode",{parentName:"p"},"get_inputs")," are listed below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Parameter"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"project"),(0,i.kt)("td",{parentName:"tr",align:null},"Project identifier to filter by")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"batch"),(0,i.kt)("td",{parentName:"tr",align:null},"Which batch in the project to return inputs for")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"external_ids"),(0,i.kt)("td",{parentName:"tr",align:null},"Return inputs matching the ",(0,i.kt)("inlineCode",{parentName:"td"},"external_ids")," supplied")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"include_invalidated"),(0,i.kt)("td",{parentName:"tr",align:null},"Filters inputs based on their status, defaults to ",(0,i.kt)("inlineCode",{parentName:"td"},"False"))))),(0,i.kt)("h3",{id:"response"},"Response"),(0,i.kt)("p",null,"The response is a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"Input")," objects containing the following properties"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Property"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"uuid"),(0,i.kt)("td",{parentName:"tr",align:null},"ID used to identify the input within the Kognic Platform")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"external_id"),(0,i.kt)("td",{parentName:"tr",align:null},"External ID supplied during input creation")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"batch"),(0,i.kt)("td",{parentName:"tr",align:null},"Which batch does the input belong to")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"view_link"),(0,i.kt)("td",{parentName:"tr",align:null},"A url to view the input in the Kognic Platform")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"input_type"),(0,i.kt)("td",{parentName:"tr",align:null},"Type of input (see ",(0,i.kt)("a",{parentName:"td",href:"/docs/"},"Input Types"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"status"),(0,i.kt)("td",{parentName:"tr",align:null},"Input status (see ",(0,i.kt)("a",{parentName:"td",href:"#input-status"},"Input Statuses"),")")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"error_message"),(0,i.kt)("td",{parentName:"tr",align:null},"If there is an error during input creation the error message will be included, otherwise it's ",(0,i.kt)("inlineCode",{parentName:"td"},"None"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"annotation_types"),(0,i.kt)("td",{parentName:"tr",align:null},"List of annotation types for the input")))),(0,i.kt)("h2",{id:"invalidate-inputs"},"Invalidate Inputs"),(0,i.kt)("p",null,"Invalidation of an input means that it will be removed for all annotation types. See ",(0,i.kt)("a",{parentName:"p",href:"/docs/kognic-io/annotation_types"},"Annotation Types"),"\non how to remove a specific annotation types for an input."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'invalid_uuids = ["0edb8f59-a8ea-4c9b-aebb-a3caaa6f2ba3", "37d9dda4-3a29-4fcb-8a71-6bf16d5a9c36"]\nreason = IAM.InvalidatedReasonInput.BAD_CONTENT\nclient.input.invalidate_inputs(invalid_uuids, reason)\n')),(0,i.kt)("p",null,"If issues are detected upstream related to inputs created, it is possible to invalidate inputs.\nInvalidated inputs will not produce annotations and any completed annotations of the input will be invalidated."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Reason"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"bad-content"),(0,i.kt)("td",{parentName:"tr",align:null},"Input does not load, or has erroneous metadata such as invalid calibration")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"duplicate"),(0,i.kt)("td",{parentName:"tr",align:null},"If same input has been created several times")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"incorrectly-created"),(0,i.kt)("td",{parentName:"tr",align:null},"If the input was unintentionally created.")))),(0,i.kt)("h2",{id:"list-invalidated-inputs"},"List Invalidated Inputs"),(0,i.kt)("p",null,"If errors are detected by Kognic, inputs will be invalidated and a reason will be supplied."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'project = "project-identifier"\nclient.input.get_inputs(project=project, include_invalidated=True)\n')),(0,i.kt)("h2",{id:"creating-multiple-inputs-with-one-call"},"Creating Multiple Inputs With One Call"),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"This feature is new in version 1.1.9")),(0,i.kt)("p",null,"Since the input creation process is asynchronous, it is sometimes useful to wait for the inputs to be created before continuing.\nIn order to do this, we provide a wrapper function ",(0,i.kt)("inlineCode",{parentName:"p"},"create_inputs")," which can create multiple scenes and inputs,\nwait for them to be created (or failed) and yield the results. The function will block until it has a result to yield\nor all of the inputs have completed in one way or another. The function takes a list of ",(0,i.kt)("inlineCode",{parentName:"p"},"SceneWithPreannotation"),"\n(a new wrapper object containing a scene and optionally a pre-annotation) along with the normal input creation parameters. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'from kognic.io.tools.input_creation import create_inputs, SceneWithPreAnnotation, InputCreationStatus\nfrom kognic.io.model.input import LidarsAndCamerasSequence\nfrom kognic.openlabel.models import OpenLabelAnnotation\n\n\nscenes_with_pre_annotations: List[SceneWithPreAnnotation] = [\n   SceneWithPreAnnotation(\n      scene=LidarsAndCamerasSequence(...), \n      preannotation=OpenLabelAnnotation(...) # Optional\n   ),\n   ...\n]\n\nfor input_result in create_inputs(client, scenes_with_pre_annotations, "project-identifier", batch="batch-identifier"):\n    # Do something with the result\n    if input_result.status == InputCreationStatus.CREATED:\n        print(f"Input {input_result.external_id} was created, got uuid {input_result.input_uuid}")\n    elif input_result.status == InputCreationStatus.FAILED:\n        print(f"Input {input_result.external_id} failed to be created at stage {input_result.error.stage} with error {input_result.error.message}")\n    else:\n        print(f"Input {input_result.external_id} is in status {input_result.status}")\n')),(0,i.kt)("p",null,"Note that the functions also accepts the parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"wait_timeout")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sleep_time")," which can be used to control the\nwait-behavior. The ",(0,i.kt)("inlineCode",{parentName:"p"},"wait_timeout")," parameter specifies the maximum time to wait for the inputs to be created/failed, while\n",(0,i.kt)("inlineCode",{parentName:"p"},"sleep_time")," specifies the time to sleep between each check. Units are in seconds. The time it takes for inputs to be created\ndepends on their size and the number of inputs to be created so the ",(0,i.kt)("inlineCode",{parentName:"p"},"wait_timeout")," should be set accordingly.\nThe default value is 30 minutes, starting from the time when all scene jobs have been committed."))}d.isMDXComponent=!0}}]);