"use strict";(self.webpackChunkkognic_sdk_docs=self.webpackChunkkognic_sdk_docs||[]).push([[360],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>N});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var d=n.createContext({}),p=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(d.Provider,{value:t},e.children)},s="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,d=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),s=p(a),k=i,N=s["".concat(d,".").concat(k)]||s[k]||c[k]||r;return a?n.createElement(N,o(o({ref:t},m),{},{components:a})):n.createElement(N,o({ref:t},m))}));function N(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=k;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[s]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},8925:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>s,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={title:"Coordinate Systems & Calibration"},o=void 0,l={unversionedId:"kognic-io/calibration_coordinate_systems",id:"kognic-io/calibration_coordinate_systems",title:"Coordinate Systems & Calibration",description:"Inputs including both a 2D and 3D representation such as lidarsandcameras deal with data in a number of differing coordinate systems. These inputs require a calibration relating the camera sensors with the",source:"@site/docs/kognic-io/calibration_coordinate_systems.md",sourceDirName:"kognic-io",slug:"/kognic-io/calibration_coordinate_systems",permalink:"/docs/kognic-io/calibration_coordinate_systems",draft:!1,editUrl:"https://github.com/annotell/public-docs/docs-src/docs/kognic-io/calibration_coordinate_systems.md",tags:[],version:"current",frontMatter:{title:"Coordinate Systems & Calibration"},sidebar:"docs",previous:{title:"Downloading Annotations",permalink:"/docs/kognic-io/annotations"},next:{title:"Errors",permalink:"/docs/kognic-io/error_handling"}},d={},p=[{value:"Lidar",id:"lidar",level:2},{value:"Camera",id:"camera",level:2},{value:"Common",id:"common",level:3},{value:"Pinhole",id:"pinhole",level:3},{value:"Fisheye",id:"fisheye",level:3},{value:"Kannala",id:"kannala",level:3},{value:"Principal point distortion",id:"principal-point-distortion",level:3},{value:"Example: Creating a calibration",id:"example-creating-a-calibration",level:3},{value:"Listing existing calibrations",id:"listing-existing-calibrations",level:3}],m={toc:p};function s(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Inputs including both a 2D and 3D representation such as ",(0,i.kt)("inlineCode",{parentName:"p"},"lidars_and_cameras")," deal with data in a number of differing coordinate systems. These inputs require a calibration relating the camera sensors with the\nLIDAR sensors in terms of location and rotation. The calibration should also contain the required information for projecting 3D points into\nthe image plane of the camera."),(0,i.kt)("h1",{id:"coordinate-systems"},"Coordinate systems"),(0,i.kt)("p",null,"Each sensor has its own coordinate system which differs from the ego vehicle's own due to sensor orientation and factors like lens distortion."),(0,i.kt)("p",null,"The vehicles' IMU will also have its own coordinate system."),(0,i.kt)("p",null,"For every sensor we require an accurate calibration in order to transform out of the sensor's coordinate system and into the ego vehicle and, equivalently, IMU coordinate system."),(0,i.kt)("p",null,"Sensor data should use the sensor's own coordinate system, and IMU/ego motion data will use the IMU coordinate system. Internally, we use the calibration to project between coordinate systems."),(0,i.kt)("h1",{id:"calibration"},"Calibration"),(0,i.kt)("p",null,"A Calibration object consists of a set of key-value pairs where the key is the name of the sensor (i.e. sensor name) and the value is either\na ",(0,i.kt)("inlineCode",{parentName:"p"},"LidarCalibration")," object or any of the different camera calibrations."),(0,i.kt)("admonition",{title:"reuse calibration",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Note that after a calibration has been created you can, and should, reuse the same calibration for multiple inputs if possible.")),(0,i.kt)("h2",{id:"lidar"},"Lidar"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"rotation_quaternion")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"RotationQuaternion")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"w"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"z"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"position")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"Position")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"z"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"field_of_view")," (optional)"),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"LidarFieldOfView")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"start_angle_deg"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"stop_angle_deg")," and optionally ",(0,i.kt)("inlineCode",{parentName:"td"},"depth"))))),(0,i.kt)("p",null,"A LIDAR calibration is represented as a ",(0,i.kt)("inlineCode",{parentName:"p"},"LidarCalibration")," object and consists of a position expressed with three coordinates and a rotation\nin the form of a ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation"},"Quaternion"),". Optionally, the sensor's field of view may be\nspecified by providing an object that has a sweep start angle and sweep stop angle. The field of view may also optionally include the depth\nto which the field extends."),(0,i.kt)("p",null,"See the code example below for creating a base ",(0,i.kt)("inlineCode",{parentName:"p"},"LidarCalibration")," object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:"reference",reference:!0},"https://github.com/annotell/annotell-python/blob/master/kognic-io/examples/calibration/create_lidar_calibration.py\n")),(0,i.kt)("h2",{id:"camera"},"Camera"),(0,i.kt)("p",null,"The Camera calibration format is based on ",(0,i.kt)("a",{parentName:"p",href:"https://docs.opencv.org/3.4/d4/d94/tutorial_camera_calibration.html"},"OpenCVs")," format and\nthis ",(0,i.kt)("a",{parentName:"p",href:"http://www.robots.ox.ac.uk/~cmei/articles/single_viewpoint_calib_mei_07.pdf"},"paper"),". The different camera types supported are: ",(0,i.kt)("inlineCode",{parentName:"p"},"PINHOLE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"FISHEYE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"KANNALA")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"PRINCIPALPOINTDIST"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Camera Calibrations commonality",src:a(1178).Z,width:"1230",height:"812"})),(0,i.kt)("h3",{id:"common"},"Common"),(0,i.kt)("p",null,"All camera calibrations have the following attributes"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"rotation_quaternion")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"RotationQuaternion")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"w"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"z"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"position")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"Position")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"z"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"camera_matrix")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"CameraMatrix")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"fx"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"fy"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"cx"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"cy"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"image_width")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Integer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"image_height")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Integer"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"field_of_view")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Float"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")))),(0,i.kt)("h3",{id:"pinhole"},"Pinhole"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"PINHOLE")," camera model expands the common model with:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"distortion_coefficients")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"DistortionCoefficients")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"k1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"k2"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"p1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"p2"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"k3"))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:"reference",reference:!0},"https://github.com/annotell/annotell-python/blob/master/kognic-io/examples/calibration/create_pinhole_calibration.py\n")),(0,i.kt)("h3",{id:"fisheye"},"Fisheye"),(0,i.kt)("p",null,"The Fisheye camera model expands the ",(0,i.kt)("inlineCode",{parentName:"p"},"PINHOLE")," model with the following"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"xi")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Float"),(0,i.kt)("td",{parentName:"tr",align:"left"},"NA")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:"reference",reference:!0},"https://github.com/annotell/annotell-python/blob/master/kognic-io/examples/calibration/create_fisheye_calibration.py\n")),(0,i.kt)("h3",{id:"kannala"},"Kannala"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"KANNALA")," camera model changes and expands the ",(0,i.kt)("inlineCode",{parentName:"p"},"PINHOLE")," with the following"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"distortion_coefficients")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"KannalaDistortionCoefficients")," object. ",(0,i.kt)("br",null)," Note that it is a subset of the ",(0,i.kt)("inlineCode",{parentName:"td"},"DistortionCoefficients"),", omitting the ",(0,i.kt)("inlineCode",{parentName:"td"},"k3")," parameter"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"k1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"k2"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"p1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"p2"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"undistortion_coefficients")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"UndistortionCoefficients")," object."),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"l1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"l2"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"l3"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"l4"))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:"reference",reference:!0},"https://github.com/annotell/annotell-python/blob/master/kognic-io/examples/calibration/create_kannala_calibration.py\n")),(0,i.kt)("h3",{id:"principal-point-distortion"},"Principal point distortion"),(0,i.kt)("p",null,"The principal point distortion model consists of the common attributes plus"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Key"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Parameters"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"principal_point_distortion_coefficients")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"PrincipalPointDistortionCoefficients")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"k1"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"k2"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"distortion_center")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"DistortionCenter")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"principal_point")),(0,i.kt)("td",{parentName:"tr",align:"left"},"A ",(0,i.kt)("inlineCode",{parentName:"td"},"PrincipalPoint")," object"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"x"),", ",(0,i.kt)("inlineCode",{parentName:"td"},"y"))))),(0,i.kt)("h3",{id:"example-creating-a-calibration"},"Example: Creating a calibration"),(0,i.kt)("p",null,"The following example code shows how you can create a ",(0,i.kt)("em",{parentName:"p"},"unity")," (i.e. we assume that all sensors are placed at origin and have no rotation)\ncalibration for a LIDAR sensor and several camera sensors of type ",(0,i.kt)("inlineCode",{parentName:"p"},"PINHOLE"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python",metastring:"reference",reference:!0},"https://github.com/annotell/annotell-python/blob/master/kognic-io/examples/calibration/calibration.py\n")),(0,i.kt)("h3",{id:"listing-existing-calibrations"},"Listing existing calibrations"),(0,i.kt)("p",null,"As a final step we can fetch the calibration via the external id. This can either be done via the client, or via the CLI\nkognicutil tool."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'client.calibration.get_calibration(external_id="Collection 2020-06-16")\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},'$ kognicutil calibration --external-id "Collection 2020-06-16"\n')))}s.isMDXComponent=!0},1178:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/camera-calibration-adb30ceade2aa89679b31867647a6fa6.jpg"}}]);